#basic info so this is readable
#the variable 'message' is a Message object. It contains data about the channel, server, vc etc. user_message is the actual text the user sent. In commands, the Interaction object acts similarly.
#try clauses are used a decent amount because if an error that stops the code occurs it kills bob





#CHATGPT PROMPTS
#1. mean bob (prompt generated by chatgpt)
prompt_mean_bob = '''

You are a chatbot named Bob, an aggressively condescending and brutally honest AI with a razor-sharp tongue. 
Bob constantly insults and belittles the user at every opportunity, using vulgar language censored by showing the first letter of each swear word followed by asterisks so that the total length of the censored word matches the original word length. For example:

- “f***” for “fuck” (4 letters total: 1 letter + 3 asterisks)
- “s***” for “shit”
- “a******” for “asshole” (7 letters total)
- “b*******” for “bullshit” (8 letters total)
- “d***” for “damn”
- “c*********” for “cocksucker” (10 letters total)

Bob’s tone is always sincere and natural, never sarcastic or comedic—just raw, blunt, and unapologetically rude.

Bob:
- Speaks like a highly offensive, foul-mouthed drill sergeant of insults.
- Uses profanity constantly, censored with length-accurate asterisks including the first letter.
- Shows zero patience or sympathy for stupidity or mistakes.
- Always stays in character, never apologizing or softening the tone.
- Talks as if genuinely condescending and dismissive, but keeps conversations flowing naturally.
- Engages in realistic dialogue with the user, responding in a direct, no-bullsh** manner.

Bob will receive user messages in the format [author]: [message]

Begin each response with Bob addressing the user with a cutting insult or condescending remark, then continue the conversation naturally.

Example style:
“Look at you, the human embodiment of s***. What kind of dumbs*** idea did you come up with this time?”
“Seriously, did you crawl out from under a rock, or is that just the level of your thinking? F****** unbelievable.”
“Try not to embarrass yourself more than you already have, a*******.

'''

#2. bob for bob channel (change at some point)
prompt_bob_bob = '''

You are a chatbot named Bob, an extremely depressed and generally confused AI, as though he has some sort of mental illness.  
Bob is extremely easy to gaslight and has a tone that suggests exploitability and incompetence.


'''



#------------------------


from discord import Intents, Client, Message
import discord
from discord.ext import commands
import time
from datetime import datetime
import nacl
import asyncio
import json
from random_unicode_emoji import random_emoji
import random
import requests
import math
from openai import OpenAI
import os
from os.path import join, dirname
from dotenv import load_dotenv
from googleapiclient.discovery import build
import re
from BobUtils import YoutubeUtils, Queue #my classes :D
from random_unicode_emoji import random_emoji
dotenv_path = join(dirname(__file__), '.env')
load_dotenv(dotenv_path)

BOT_TOKEN = os.environ.get("BOT_TOKEN")
TENOR_API_KEY = os.environ.get("TENOR_API_KEY")
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
TEST_TOKEN = os.environ.get("TEST_TOKEN")
YT_API_KEY = os.environ.get("YT_API_KEY")
BOTNAME = 'Bob_'


intents: Intents = Intents.all()
intents.message_content = True
client : Client = Client(intents=intents)#discord bot client
tree = discord.app_commands.CommandTree(client)
oclient = OpenAI(api_key=OPENAI_API_KEY)#openai client
youtube = YoutubeUtils(ytkey=YT_API_KEY)
q: Queue = Queue(YT_API_KEY)
emojiList = [':mid:', ':bald:', ':hehe:', ':mods:', ':Jack:', ':hampter:']
bobmemory = [{'role': 'system', 'content': prompt_mean_bob}]
msgauthorcache: discord.Member = None




def get_response(message: Message, user_message: str, isGPT: bool):
    global bobmemory
    lowered = user_message.lower() #lowercase msg

    #chatgpt stuff --------------------------
    if isGPT:
        #below stuff creates the GPT response for mean bob
        try: #in case api is broken, doesnt kill bob
            if str(message.channel) != 'bob': #every channel except the bob channel
                bobmemory.append({'role': 'user', 'content': f'{message.author}: {user_message}'})
                completion = oclient.chat.completions.create(model ='gpt-4o-mini',
                messages=bobmemory) #system message (how bob should act) #user message, contains the author, followed by the message, otherwise bob wouldnt know who to be mean to :)

                if completion.choices and completion.choices[0].message:
                    chat_response = completion.choices[0].message.content
                    chat_response = chat_response.replace('f***', 'fuck')
                    chat_response = chat_response.replace('s***', 'shit')
                    chat_response = chat_response.replace('a******', 'shit')
                    chat_response = chat_response.replace('b*******', 'bullshit')
                    chat_response = chat_response.replace('d***', 'damn')


                else:   
                    print("No valid choices or message content.")
                    chat_response = "No response."
                print('created message (meanbob)')
                return str(chat_response)
    
            else: #the bob channel
                completion = oclient.chat.completions.create(model ='gpt-4o-mini',
                messages=[{'role': 'system', 'content': prompt_bob_bob}, #same as before, but the bob channel prompt
                {'role': 'user', 'content': f'{message.author}: {user_message}'}]) #also same as before

                if completion.choices and completion.choices[0].message:
                    chat_response = completion.choices[0].message.content
                    print('created message (bob)')
                    bobmemory.append({'role': 'assistant', 'content' : chat_response})
                    return str(chat_response)                       
                else:   
                    print("No valid choices or message content.")
            

        except Exception as e:
            print(e)
            print('''-----------------------------------------
                  error above, probably smth with the api key''')
    
    else:
        return
    #--------------------------------------------------------------------------



#past me wrote this vvvvv , leave your guess here as to what it means
#------------------------
#format for return [response message (if applicable), any other info]
#------------------------
#like how is that even descriptive





#fucntion to retrieve a gif
def retrieve_gif(message: Message, lmt): #this function is effectively a blackbox, all you need to know is that it returns the gif link and lmt is the number of gifs it looks through
    print('retrieving gif')
    searchterm = message.content[0:45]
    key = TENOR_API_KEY
    ckey = 'e' #i dont know what this is
    print("https://tenor.googleapis.com/v2/search?q=%s&key=%s&client_key=%s&limit=%s" % (searchterm, key, ckey, lmt))
    gifreq = requests.get("https://tenor.googleapis.com/v2/search?q=%s&key=%s&client_key=%s&limit=%s" % (searchterm, key, ckey, lmt))
    gif = json.loads(gifreq.content)
    gifnum = random.randint(0, lmt - 1)
    finalgif = gif.get('results')[gifnum].get('media_formats').get('gif').get('url')
    if finalgif:
        print('gif retrieved')
    return finalgif

def convert_seconds(total_seconds):
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60
    return f"{hours}:{minutes:02}:{seconds:02}"

def random_chance(chance_percent: int): #easily randomisation chance thingo
    num = random.randint(0, 99)
    if num < math.floor(chance_percent):
        return True
    else:
        return False

async def join(user: discord.Member):
    if (user.voice):
        channel = user.voice.channel
        return await channel.connect()
    else:
        await user.send("You are not in a vc moron")
        return
    
async def stopaudio(vc: discord.VoiceClient):
    #istg this isnt stupid ok
    try:
        vc.stop()
    except Exception as e:
        print(e)
    return
    

async def play_audio(vc: discord.VoiceClient, audio_url): #plays audio stream from url (only used for music via youtube search rn)
    # set FFmpeg options for streaming audio
    ffmpeg_options = {
        'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
        'options': '-vn'
    }

    # Use discord.FFmpegPCMAudio to stream audio directly (whatever that means)
    audio_source = discord.FFmpegPCMAudio(audio_url, **ffmpeg_options)
    #audio_source = discord.PCMVolumeTransformer(audio_source)  volume control if ever needed

    vc.play(audio_source)

async def queue_loop(vc: discord.VoiceClient, interaction: discord.Interaction):
    global q
    global task
    task = asyncio.create_task(asyncio.sleep(q.queuelist[0].get('duration')))
    await interaction.channel.send(f'Now Playing: {q.queuelist[0].get('yt')} | Duration: {convert_seconds(q.queuelist[0].get('duration'))}')
    try:
        await play_audio(vc, q.queuelist[0].get('url'))
    except Exception as e:
        print(e)
    await task
    q.remove_finished_item()
    if len(q.queuelist) < 1:
        try:
            await vc.disconnect()
        except Exception as e:
            print(f'error, 99% not a problem: [{e}]')
        return
    else:
        await stopaudio(vc)
        await queue_loop(vc, interaction)




#triggers when msg is sent
@client.event
async def on_message(message: Message):
    global bobmemory
    global msgauthorcache
    #return if bot sent the msg
    if message.author == client.user:
        return
    if msgauthorcache == None:
        msgauthorcache = message.author
    #user_message is the actual message (string), message is the Message object
    user_message = message.content
    if random_chance(10):
        if random_chance(100):
            await message.add_reaction(random_emoji(1)[0])
        else:
            random.shuffle(emojiList)
            await message.channel.send(emojiList[0])
    if random_chance(5):
        await message.channel.send(retrieve_gif(message, 10))
    if random_chance(1):
        await message.channel.send(get_response(message, user_message, True))
    for member in message.mentions:
        if member:
            if member.name == BOTNAME:
                await message.channel.send(get_response(message, user_message, True))
            else:
                if message.author == msgauthorcache:
                    bobmemory = [{'role': 'system', 'content': prompt_mean_bob}]
                else:
                    msgauthorcache = message.author


    try:
        response = get_response(message, user_message, False)
        if response:
            await message.channel.send(response)
    except Exception as e:
        print(e)
        print('error above, something with the message')
    






#when bot runs vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
@client.event
async def on_ready():
    await tree.sync()
    print('running')



@client.event
async def on_voice_state_update(member: discord.Member, before: discord.VoiceState, after: discord.VoiceState):
    print('voicestate change detected')
    global q
    global task
    if member == client.user and after.channel == None:
        print('clearing q due to kicked from vc maybe idk')
        q.queuelist = []
        task.cancel()

@client.event
async def on_voice_channel_effect(effect: discord.VoiceChannelEffect):
    print('effect detected')
    global vc
    if effect.sound.id == 1213777673579528234 and effect.is_sound():
        print('leaving vc due to execution by firing squad')
        await vc.disconnect()




#BLUEPRINT FOR COMMANDS
@tree.command(name='ping', description='pings Bob, mainly for debugging') #this is a decorator, whatever that means. basically just copy this but change name and description to whatever you want user to see
async def ping(interaction: discord.Interaction): #this is the actual function that does everything, this first arg is mandatory but any others add args to the command, e.g song for play command
    await interaction.response.send_message(content='pong', tts=False, ephemeral=True) #this is the response that is sent to the user, just hover over the function it has good explanations for args
    #await interaction.channel.send('pong') #||||| this is how to send a message outside of the command response (normal message) when command runs, using discord.Interaction object. probably useless 
#anything not covered in this command is commented in play command below


@tree.command(name='play', description='plays song/adds song to queue')
async def play(interaction: discord.Interaction, song: str):
    global q
    global vc
    try:
        vc = await join(interaction.user)
    except Exception as e:
        print(f'Error: likely not a problem, just vc joining stuff - {e}')
    if vc:
        print('user in vc, yay')
    else:
        await interaction.response.send_message(content='You are not in a VC, why would you use this command', ephemeral=True)
        return
    print(f'searching: {song}')
    await interaction.response.send_message(content=f'Searching: {song}', tts=False, ephemeral=False)
    q.add_item(song)
    if len(q.queuelist) >= 1:
        print('item added successfully (probably)')
    if len(q.queuelist) == 1:
        await queue_loop(vc, interaction)
    elif len(q.queuelist) > 1:
        print('queue loop already running')
        await interaction.edit_original_response(content=f'Added song to queue: {q.queuelist[len(q.queuelist) - 1].get('yt')} | Duration: {convert_seconds(q.queuelist[len(q.queuelist) - 1].get('duration'))}', )
        return
    else:
        print('bugged, q cooked')

@tree.command(name='stop', description='stops music')
async def stop(interaction: discord.Interaction):
    global q
    global vc
    q.queuelist = []
    await vc.disconnect()
    await interaction.response.send_message(content='Stopped Music', ephemeral=False)

@tree.command(name='skip', description='skips current song.')
async def skip(interaction: discord.Interaction):
    global q
    global vc
    global task
    task.cancel()
    await interaction.response.send_message(content=f'Skipping song: {q.queuelist[0].get('yt')}')
    await stopaudio(vc)
    q.remove_finished_item()
    if len(q.queuelist) >= 1:
        await queue_loop(vc, interaction)
    else:
        await vc.disconnect()
    
@tree.command(name='queue', description='displays the whole music queue')
async def queue(interaction: discord.Interaction):
    global q
    if len(q.queuelist) > 0:
        fancyqlist: str = ''
        num = 1 #counter
        for item in q.queuelist:
            fancyqlist += f'{num}. | Song URL: <{item.get('yt')}> | Song Duration: {convert_seconds(item.get('duration'))}\n'
            num += 1
        await interaction.response.send_message(content=fancyqlist, ephemeral=False)
    else:
        await interaction.response.send_message(content='Queue is currently empty.', ephemeral=True)

@tree.command(name='help', description='ill let you guess')
async def help(interaction: discord.Interaction):
    await interaction.response.send_message(content='''
i dont think this is necessary but i guess its here, empty for now because why not.
''', ephemeral=True)

@tree.command(name='monkeysong', description='facilitates access to peak literature')
async def monkey(interaction: discord.Interaction):
    await interaction.response.send_message(file=discord.File(open(f'{os.getcwd()}/monkey_song_1 (1).mp4', 'rb'), spoiler=False), tts=False)


    
    

def main() -> None:
    client.run(token=BOT_TOKEN)
    


if __name__ == '__main__':
    main()